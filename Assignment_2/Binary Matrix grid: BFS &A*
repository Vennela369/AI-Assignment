
from __future__ import annotations
from typing import List, Tuple, Callable, Optional, Dict
import heapq
import math

Coord = Tuple[int, int]
Grid = List[List[int]]

# ------------------------- Heuristics -------------------------

def manhattan(a: Coord, b: Coord) -> float:
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def euclidean(a: Coord, b: Coord) -> float:
    return math.hypot(a[0] - b[0], a[1] - b[1])

# ------------------------- Utilities -------------------------

# 8-directional neighbors (dx, dy)
DIRS = [
    (-1, -1), (-1, 0), (-1, 1),
    ( 0, -1),          ( 0, 1),
    ( 1, -1), ( 1, 0), ( 1, 1),
]

def in_bounds(grid: Grid, r: int, c: int) -> bool:
    return 0 <= r < len(grid) and 0 <= c < len(grid[0])

def is_open(grid: Grid, r: int, c: int) -> bool:
    return grid[r][c] == 0

def reconstruct_path(came_from: Dict[Coord, Coord], end: Coord) -> List[Coord]:
    path = [end]
    while path[-1] in came_from:
        path.append(came_from[path[-1]])
    path.reverse()
    return path

def validate_grid(grid: Grid) -> None:
    if not grid or not grid[0]:
        raise ValueError("Grid must be non-empty")
    n = len(grid)
    if any(len(row) != n for row in grid):
        raise ValueError("Grid must be square (n x n)")
    if not is_open(grid, 0, 0) or not is_open(grid, n-1, n-1):
        # No path possible if start or goal is blocked
        return

# -- Greedy Best-First Search ----------

def greedy_best_first_search(
    grid: Grid,
    heuristic: Callable[[Coord, Coord], float] = euclidean
) -> Tuple[int, Optional[List[Coord]]]:
    """
    Greedy Best-First Search (GBFS): prioritizes nodes with smallest h(n).
    Returns (path_length, path) where path is a list of coordinates or None if no path.
    Path length is the number of visited cells in the path (as per prompt).
    """
    n = len(grid)
    start, goal = (0, 0), (n - 1, n - 1)
    if not is_open(grid, *start) or not is_open(grid, *goal):
        return -1, None

    open_heap = []  # (priority = h, coord)
    heapq.heappush(open_heap, (heuristic(start, goal), start))
    came_from: Dict[Coord, Coord] = {}
    visited = set([start])

    while open_heap:
        _, current = heapq.heappop(open_heap)

        if current == goal:
            path = reconstruct_path(came_from, current)
            return len(path), path

        cr, cc = current
        for dr, dc in DIRS:
            nr, nc = cr + dr, cc + dc
            if in_bounds(grid, nr, nc) and is_open(grid, nr, nc):
                nxt = (nr, nc)
                if nxt not in visited:
                    visited.add(nxt)
                    came_from[nxt] = current
                    heapq.heappush(open_heap, (heuristic(nxt, goal), nxt))

    return -1, None

# -------------------A* Search -----------------

def a_star_search(
    grid: Grid,
    heuristic: Callable[[Coord, Coord], float] = euclidean
) -> Tuple[int, Optional[List[Coord]]]:
    """
    A* Search: f(n) = g(n) + h(n), where g(n) is cost from start.
    Cost of moving to any neighbor is 1 (each visited cell counts as 1 toward path length).
    Returns (path_length, path) or (-1, None) if no path.
    """
    n = len(grid)
    start, goal = (0, 0), (n - 1, n - 1)
    if not is_open(grid, *start) or not is_open(grid, *goal):
        return -1, None

    g_score: Dict[Coord, float] = {start: 0.0}
    came_from: Dict[Coord, Coord] = {}

    open_heap = []  # (f, g, coord)
    start_h = heuristic(start, goal)
    heapq.heappush(open_heap, (start_h, 0.0, start))

    in_open = {start}

    while open_heap:
        f, g, current = heapq.heappop(open_heap)
        in_open.discard(current)

        if current == goal:
            path = reconstruct_path(came_from, current)
            return len(path), path

        cr, cc = current
        for dr, dc in DIRS:
            nr, nc = cr + dr, cc + dc
            if not in_bounds(grid, nr, nc) or not is_open(grid, nr, nc):
                continue

            neighbor = (nr, nc)
            tentative_g = g + 1  # each step costs 1 (counts cell transitions)

            if tentative_g < g_score.get(neighbor, float("inf")):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_new = tentative_g + heuristic(neighbor, goal)
                if neighbor not in in_open:
                    heapq.heappush(open_heap, (f_new, tentative_g, neighbor))
                    in_open.add(neighbor)

    return -1, None

# ---------------------- Pretty Printing ---------------------

def format_path(path: Optional[List[Coord]]) -> str:
    if not path:
        return ""
    return "[" + ", ".join(f"({r},{c})" for r, c in path) + "]"

def run_and_print(grid: Grid, name: str, algo) -> None:
    length, path = algo(grid)
    if length == -1:
        print(f"{name:<20} →  Path length: -1")
    else:
        print(f"{name:<20} →  Path length: {length}, Path: {format_path(path)}")

# ------------------------- Example Usage / Tests -------------------------

def main():
    # Example 1
    grid1 = [
        [0, 1],
        [1, 0],
    ]

    # Example 2
    grid2 = [
        [0, 0, 0],
        [1, 1, 0],
        [1, 1, 0],
    ]

    # Example 3
    grid3 = [
        [1, 0, 0],
        [1, 1, 0],
        [1, 1, 0],
    ]

    print("Using Euclidean heuristic\n")

    print("Example 1:")
    run_and_print(grid1, "Best First Search", greedy_best_first_search)
    run_and_print(grid1, "A* Search", a_star_search)
    print()

    print("Example 2:")
    run_and_print(grid2, "Best First Search", greedy_best_first_search)
    run_and_print(grid2, "A* Search", a_star_search)
    print()

    print("Example 3:")
    run_and_print(grid3, "Best First Search", greedy_best_first_search)
    run_and_print(grid3, "A* Search", a_star_search)
    print()

if __name__ == "__main__":
    main()
